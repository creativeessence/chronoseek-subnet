# Basilica Container Execution Reference

overview:
  what: "Pod orchestration for miner Docker containers"
  when: "Miners compete on software quality, not hardware"
  integration: "Affinetes framework"

trigger_condition:
  question: "Is competitive advantage from CODE WRITTEN?"
  if_yes: "Use Basilica containers"
  if_no: "Query-based pattern may work"
  
  examples_use_containers:
    - trading_agents
    - task_solvers
    - optimization_algorithms
    - game_playing_bots
    - code_generators
    - tsp_solvers
    - chess_engines

workflow:
  miner:
    1: "create env.py with Actor class"
    2: "create Dockerfile"
    3: "create requirements.txt"
    4: "build: afs build my-env --tag v1 --push"
    5: "commit image URL to chain"
  
  validator:
    1: "read miner's image from chain"
    2: "load env via Basilica"
    3: "call Actor methods"
    4: "score results"
    5: "cleanup"

env_py_template: |
  import os
  import openai
  import httpx
  
  class Actor:
      def __init__(self):
          self.api_key = os.getenv("CHUTES_API_KEY")
      
      async def evaluate(
          self,
          task_id: int,
          model: str = "Qwen/Qwen3-32B",
          base_url: str = "https://llm.chutes.ai/v1",
          timeout: int = 600,
          **kwargs
      ) -> dict:
          client = openai.AsyncOpenAI(
              base_url=base_url,
              api_key=self.api_key,
              timeout=httpx.Timeout(timeout)
          )
          # evaluation logic
          return {"task_id": task_id, "score": score}

dockerfile_template: |
  FROM python:3.11-slim
  WORKDIR /app
  COPY requirements.txt .
  RUN pip install --no-cache-dir -r requirements.txt
  COPY . .

affinetes_api:
  build: |
    af_env.build_image_from_env(
        env_path="my-env",
        image_tag="my-env:v1",
        push=True,
        registry="docker.io/myuser"
    )
  
  load: |
    env = af_env.load_env(
        mode="basilica",
        image="myuser/my-env:v1",
        cpu_limit="2000m",
        mem_limit="8Gi",
        env_vars={"CHUTES_API_KEY": os.getenv("CHUTES_API_KEY")}
    )
  
  execute: |
    result = await env.evaluate(task_id=42, model="Qwen/Qwen3-32B")
  
  cleanup: |
    await env.cleanup()

execution_modes:
  docker:
    purpose: "local development"
    usage: 'mode="docker"'
  
  basilica:
    purpose: "production validation"
    usage: 'mode="basilica"'
    auth: "BASILICA_API_TOKEN env var"
  
  url:
    purpose: "user-deployed services"
    usage: 'mode="url", base_url="http://..."'

parallel_execution: |
  async def evaluate_tasks(image: str, task_ids: list, concurrent: int = 10):
      env = af_env.load_env(mode="basilica", image=image, ...)
      semaphore = asyncio.Semaphore(concurrent)
      
      async def run_task(tid):
          async with semaphore:
              return await env.evaluate(task_id=tid)
      
      try:
          tasks = [run_task(tid) for tid in task_ids]
          return await asyncio.gather(*tasks, return_exceptions=True)
      finally:
          await env.cleanup()

best_practices:
  miners:
    - keep_containers_small
    - use_chutes_for_llm_inference
    - handle_errors_gracefully
    - version_images: "v1, v2, etc"
    - test_locally_first
  
  validators:
    - set_timeouts: "both container and client"
    - limit_concurrency: "semaphores"
    - handle_failures: "score 0, don't crash"
    - always_cleanup: "try/finally"
    - cache_results: "for unchanged versions"

comparison_vs_query:
  query_based_problems:
    - miner_runs_own_server
    - validator_queries_black_box
    - cant_audit_execution
    - unbounded_attack_surface
  
  basilica_advantages:
    - miner_commits_code
    - validator_runs_actual_code
    - image_is_submission
    - sandboxed_reproducible
