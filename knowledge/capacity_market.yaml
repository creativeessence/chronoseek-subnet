# Pattern: Capacity/Uptime Marketplace
# Example: Chutes (SN64)

metadata:
  name: capacity_market
  category: compute
  examples: ["Chutes SN64"]

when_to_use:
  commodity: "always-on infrastructure"
  value_source: "actual usage/uptime"
  verification: "GPU authenticity (GraVal)"
  public_endpoint: false

architecture:
  miner:
    registration: "hotkey on subnet"
    infrastructure: "Kubernetes GPU cluster"
    connection: "socket.io to central orchestrator"
    authentication: "hotkey signature"
    public_endpoint: false
    provides:
      - hourly_cost
      - gpu_type
      - vram_gb
  
  orchestrator:
    role: central_job_router
    connection: socket.io
    routes: jobs_to_miners
    tracks: usage_billing
  
  validator:
    queries: "orchestrator for usage history"
    window: "rolling 7 days"
    applies:
      - blacklists
      - coldkey_deduplication
    scoring: "billed compute delivered"
    output: "normalized u16 weights"

gpu_verification:
  method: "GraVal cryptographic proofs"
  purpose: "ensure authentic hardware"

anti_gaming:
  graval_proofs: "cryptographic GPU verification"
  coldkey_dedup: "highest scorer per coldkey only"
  billed_uptime: "prevents idle node registration"

socket_pattern:
  connection: "miner → orchestrator via socket.io"
  authentication: "hotkey signature on connect"
  job_handling: "receive job → execute → return result"
  no_public_endpoint: true

scoring:
  metric: "total billed compute over window"
  window: "7 days rolling"
  normalization: "divide by total network billed"

selection_criteria:
  use_when:
    - always_on_infrastructure
    - usage_based_billing
    - no_direct_query_needed
    - central_orchestration_acceptable
  
  dont_use_when:
    - direct_miner_queries_needed
    - decentralized_discovery_required
    - price_competition_primary
