# Pattern: Container Execution (Basilica)
# Use when miners compete on SOFTWARE quality, not HARDWARE

metadata:
  name: container_execution
  category: agent_environment
  requires: ["Basilica", "Chutes"]

when_to_use:
  trigger_question: "Are miners competing on CODE they write?"
  examples:
    use_containers:
      - trading_agents
      - task_solvers
      - optimization_algorithms
      - game_playing_bots
      - code_generators
      - tsp_solvers
      - chess_engines
    
    query_based_ok:
      - gpu_inference_hosting
      - storage_provision
      - bandwidth_services

rule: |
  If competitive advantage comes from CODE WRITTEN (not hardware run),
  use containers. Validators run the code, not query black boxes.

architecture:
  miner:
    workflow:
      1: "create env.py with Actor class"
      2: "build Docker image"
      3: "push to Docker Hub"
      4: "commit image URL to chain"
    
    env_py_structure:
      class: Actor
      methods:
        - evaluate(task_id, model, **kwargs)
      chutes_access: "via CHUTES_API_KEY env var"
  
  validator:
    workflow:
      1: "read miner's image URL from chain"
      2: "load environment via Basilica"
      3: "call Actor methods"
      4: "score results"
      5: "cleanup"
    
    code_pattern: |
      env = af_env.load_env(
          mode="basilica",
          image=miner_image_url,
          env_vars={"CHUTES_API_KEY": api_key}
      )
      result = await env.evaluate(task_id=42)
      await env.cleanup()

comparison:
  query_based_WRONG:
    - miner_runs_own_server
    - validator_queries_black_box
    - cant_audit_whats_running
    - miner_needs_infrastructure
    - unbounded_attack_surface
  
  basilica_CORRECT:
    - miner_just_commits_code
    - validator_runs_actual_code
    - docker_image_IS_submission
    - miner_needs_only_docker_hub
    - sandboxed_reproducible

affinetes_api:
  build: |
    af_env.build_image_from_env(
        env_path="my-env",
        image_tag="my-env:v1",
        push=True,
        registry="docker.io/myuser"
    )
  
  load: |
    env = af_env.load_env(
        image="myuser/my-env:v1",
        mode="basilica",  # or "docker" for local
        env_vars={"CHUTES_API_KEY": "xxx"}
    )
  
  execute: |
    result = await env.evaluate(task_id=1, model="Qwen/Qwen3-32B")
  
  cleanup: |
    await env.cleanup()

execution_modes:
  docker: "local Docker daemon (development)"
  basilica: "remote pod provisioning (production)"
  url: "connect to existing service"

chutes_integration:
  purpose: "LLM inference inside containers"
  pattern: "containers use Chutes API, no local GPU"
  api: "OpenAI-compatible at llm.chutes.ai"
  key_injection: "CHUTES_API_KEY env var"

best_practices:
  miners:
    - keep_containers_small
    - use_chutes_for_inference
    - handle_errors_gracefully
    - version_images_semantically
    - test_locally_first
  
  validators:
    - set_timeouts
    - limit_concurrency
    - handle_failures
    - always_cleanup
    - cache_unchanged_versions

selection_criteria:
  use_when:
    - miners_building_algorithms
    - miners_building_agents
    - miners_building_solvers
    - competition_on_software_quality
  
  dont_use_when:
    - hosting_existing_models
    - hardware_is_commodity
    - simple_api_responses_sufficient
