# Python SDK Quick Reference

installation:
  packages:
    - bittensor
    - bittensor-wallet
    - bittensor-cli

subtensor:
  sync:
    init: |
      from bittensor import Subtensor
      subtensor = Subtensor(network="finney")  # or "test", "local"
    
    queries:
      block: "subtensor.get_current_block()"
      balance: "subtensor.get_balance(coldkey_ss58)"
      subnet_exists: "subtensor.subnet_exists(netuid)"
      hyperparams: "subtensor.get_subnet_hyperparameters(netuid)"
      is_registered: "subtensor.is_hotkey_registered(netuid, hotkey_ss58)"
      uid_for_hotkey: "subtensor.get_uid_for_hotkey_on_subnet(netuid, hotkey_ss58)"
      metagraph: "subtensor.metagraph(netuid)"
    
    transactions:
      register: "subtensor.burned_register(wallet, netuid)"
      set_weights: |
        subtensor.set_weights(
            wallet=wallet,
            netuid=netuid,
            uids=[0, 1, 2],
            weights=[0.5, 0.3, 0.2],
            wait_for_inclusion=True
        )
      
      commit: |
        subtensor.set_commitment(
            wallet=wallet,
            netuid=netuid,
            data="https://api.myminer.com"
        )
      
      commit_reveal: |
        subtensor.set_reveal_commitment(
            wallet=wallet,
            netuid=netuid,
            data="secret_data",
            blocks_until_reveal=360,
            block_time=12
        )
      
      add_stake: |
        subtensor.add_stake(
            wallet=wallet,
            netuid=netuid,
            hotkey_ss58=hotkey,
            amount=Balance.from_tao(10),
            safe_staking=True,
            mev_protection=True
        )
  
  async:
    init: |
      from bittensor import AsyncSubtensor
      async_subtensor = AsyncSubtensor(network="finney")
    
    usage: "await async_subtensor.method_name()"

wallet:
  init: |
    from bittensor_wallet import Wallet
    wallet = Wallet(name="my_wallet", hotkey="my_hotkey")
    wallet.create_if_non_existent()
  
  addresses:
    coldkey: "wallet.coldkey.ss58_address"
    hotkey: "wallet.hotkey.ss58_address"
  
  signing: |
    signature = wallet.hotkey.sign(message.encode())

metagraph:
  init: |
    from bittensor import Metagraph
    metagraph = Metagraph(netuid=1, network="finney")
    metagraph.sync(subtensor=subtensor)  # or lite=True
  
  arrays:
    S: "stake"
    I: "incentive"
    D: "dividends"
    E: "emission"
    T: "trust"
    C: "consensus"
    R: "rank"
    hotkeys: "hotkey addresses"
    coldkeys: "coldkey addresses"
    validator_permit: "can validate"
  
  matrices:
    W: "weights[validator][miner]"
    B: "bonds[validator][miner]"
  
  access: |
    stake = metagraph.S[uid]
    hotkey = metagraph.hotkeys[uid]
    uid = metagraph.hotkeys.index(hotkey_ss58)

commitments:
  rate_limit:
    constraint: "1 commitment per 100 blocks (~20 minutes)"
    implication: "commit STORAGE LOCATION, not individual data items"
    correct_pattern: "commit bucket URL or API endpoint once, validators pull from it"
    incorrect_pattern: "commit each CID or data hash to chain"
  
  basic:
    write: "subtensor.set_commitment(wallet, netuid, data)"
    read_by_uid: "subtensor.get_commitment(netuid, uid)"
    read_all: "subtensor.get_all_commitments(netuid)"
  
  commit_reveal:
    write: |
      subtensor.set_reveal_commitment(
          wallet, netuid, data,
          blocks_until_reveal=360,
          block_time=12
      )
    read_revealed_uid: "subtensor.get_revealed_commitment(netuid, uid)"
    read_revealed_all: "subtensor.get_all_revealed_commitments(netuid)"

subnet_tokens:
  concepts:
    tao: "base network token"
    alpha: "subnet-specific token"
    price: "TAO per Alpha"
    slippage: "price impact from pool movement"
    pool: "tao_in × alpha_in = k (constant)"

  get_info:
    single: "subnet = subtensor.subnet(netuid)"
    all: "subnets = subtensor.all_subnets()"
    price_only: "subtensor.get_subnet_price(netuid)"
    all_prices: "subtensor.get_subnet_prices()"

  dynamic_info_fields:
    netuid: "int - subnet ID"
    owner_hotkey: "str - owner hotkey SS58"
    owner_coldkey: "str - owner coldkey SS58"
    subnet_name: "str - human name"
    symbol: "str - token symbol (e.g. α1)"
    tempo: "int - blocks per epoch"
    last_step: "int - last epoch block"
    blocks_since_last_step: "int"
    emission: "Balance - total emission"
    alpha_in: "Balance - Alpha in pool"
    alpha_out: "Balance - Alpha staked"
    tao_in: "Balance - TAO in pool"
    price: "Balance - TAO per Alpha"
    k: "float - pool constant"
    is_dynamic: "bool - true except netuid 0"
    moving_price: "float - time-weighted avg"
    subnet_volume: "Balance - trading volume"
    network_registered_at: "int - creation block"

  conversion:
    ideal_no_slippage: |
      alpha = subnet.tao_to_alpha(10.0)      # 10 TAO → ? Alpha
      tao = subnet.alpha_to_tao(100.0)       # 100 Alpha → ? TAO
    
    with_slippage: |
      alpha_out, slippage = subnet.tao_to_alpha_with_slippage(100.0)
      tao_out, slippage = subnet.alpha_to_tao_with_slippage(1000.0)
      slippage_pct = subnet.tao_to_alpha_with_slippage(100.0, percentage=True)
    
    aliases:
      - "subnet.slippage(tao) = tao_to_alpha_with_slippage"
      - "subnet.tao_slippage(tao) = tao_to_alpha_with_slippage"
      - "subnet.alpha_slippage(alpha) = alpha_to_tao_with_slippage"

  simulate_swap: |
    from bittensor.utils.balance import Balance
    
    # Simulate staking (TAO → Alpha)
    result = subtensor.sim_swap(
        origin_netuid=0,        # 0 = TAO
        destination_netuid=1,   # target subnet
        amount=Balance.from_tao(100)
    )
    print(f"TAO fee: {result.tao_fee}, Alpha out: {result.alpha_amount}")
    
    # Simulate unstaking (Alpha → TAO)
    result = subtensor.sim_swap(
        origin_netuid=1,        # source subnet
        destination_netuid=0,   # 0 = TAO
        amount=Balance.from_tao(100)
    )

  staking:
    add_stake: |
      result = subtensor.add_stake(
          wallet=wallet,
          netuid=1,
          hotkey_ss58=wallet.hotkey.ss58_address,
          amount=Balance.from_tao(10),
          safe_staking=True,        # price protection
          rate_tolerance=0.005,     # max 0.5% price increase
          allow_partial_stake=True, # partial if tolerance exceeded
          mev_protection=True,      # encrypt against front-running
          wait_for_finalization=True
      )
    
    add_stake_multiple: |
      result = subtensor.add_stake_multiple(
          wallet=wallet,
          netuids=[1, 2, 3],
          hotkey_ss58s=[hotkey1, hotkey2, hotkey3],
          amounts=[Balance.from_tao(10), Balance.from_tao(20), Balance.from_tao(30)],
          mev_protection=True
      )

  unstaking:
    unstake: |
      result = subtensor.unstake(
          wallet=wallet,
          netuid=1,
          hotkey_ss58=wallet.hotkey.ss58_address,
          amount=Balance.from_tao(100),  # in Alpha
          safe_unstaking=True,
          rate_tolerance=0.005,
          allow_partial_stake=True,
          mev_protection=True
      )
    
    unstake_all: |
      result = subtensor.unstake_all(
          wallet=wallet,
          netuid=1,
          hotkey_ss58=wallet.hotkey.ss58_address,
          rate_tolerance=0.005,  # or None for no limit
          mev_protection=True
      )
    
    unstake_multiple: |
      result = subtensor.unstake_multiple(
          wallet=wallet,
          netuids=[1, 2, 3],
          hotkey_ss58s=[hotkey1, hotkey2, hotkey3],
          amounts=[Balance.from_tao(100), Balance.from_tao(200), None],  # None = all
          mev_protection=True
      )

  get_stake:
    single: |
      stake = subtensor.get_stake(
          coldkey_ss58=wallet.coldkeypub.ss58_address,
          hotkey_ss58=wallet.hotkey.ss58_address,
          netuid=1
      )
    
    all_for_coldkey: |
      stakes = subtensor.get_stake_info_for_coldkey(coldkey_ss58=coldkey)
      for stake in stakes:
          print(f"Subnet {stake.netuid}: {stake.stake} on {stake.hotkey_ss58}")

  safe_staking_explanation:
    purpose: "price protection against manipulation"
    safe_staking_true:
      - "includes price limit in transaction"
      - "fails or partial if price moves > rate_tolerance"
      - "protects against front-running and MEV"
    safe_staking_false:
      - "exact amount but may suffer slippage"

  mev_protection_explanation:
    purpose: "encrypt transaction to prevent front-running"
    how_it_works:
      - "transaction encrypted via MEV Shield pallet"
      - "validators decrypt after inclusion"
      - "prevents bots from seeing your trade"
    recommended_for: "large trades"

  balance_utilities: |
    from bittensor.utils.balance import Balance
    
    tao = Balance.from_tao(100)
    rao = Balance.from_rao(1e9)  # 1 TAO
    
    print(f"TAO: {tao.tao}, RAO: {tao.rao}")
    
    alpha = Balance.from_tao(100).set_unit(1)  # Alpha for subnet 1
    total = tao + Balance.from_tao(50)

epistula:
  create_headers: |
    import time, hashlib
    
    def create_epistula_headers(wallet, body: bytes) -> dict:
        nonce = str(int(time.time() * 1e9))
        body_hash = hashlib.sha256(body).hexdigest()
        message = f"{nonce}.{body_hash}"
        signature = wallet.hotkey.sign(message.encode()).hex()
        
        return {
            "X-Epistula-Timestamp": nonce,
            "X-Epistula-Signature": signature,
            "X-Epistula-Hotkey": wallet.hotkey.ss58_address
        }
  
  verify: |
    from substrateinterface import Keypair
    
    def verify_epistula(request, body: bytes) -> str:
        ts = request.headers["X-Epistula-Timestamp"]
        sig = request.headers["X-Epistula-Signature"]
        hotkey = request.headers["X-Epistula-Hotkey"]
        
        if abs(time.time() - int(ts)/1e9) > 60:
            raise ValueError("Timestamp too old")
        
        body_hash = hashlib.sha256(body).hexdigest()
        message = f"{ts}.{body_hash}"
        kp = Keypair(ss58_address=hotkey)
        
        if not kp.verify(message.encode(), bytes.fromhex(sig)):
            raise ValueError("Invalid signature")
        
        return hotkey

common_patterns:
  ensure_registered: |
    if not subtensor.is_hotkey_registered(netuid, wallet.hotkey.ss58_address):
        subtensor.burned_register(wallet=wallet, netuid=netuid)
    uid = subtensor.get_uid_for_hotkey_on_subnet(netuid, wallet.hotkey.ss58_address)
  
  weight_setting_with_rate_limit: |
    params = subtensor.get_subnet_hyperparameters(netuid)
    if current_block - last_set_block >= params.weights_rate_limit:
        subtensor.set_weights(wallet, netuid, uids, weights)
        last_set_block = current_block
  
  metagraph_sync_loop: |
    while True:
        metagraph.sync(subtensor=subtensor, lite=True)
        await asyncio.sleep(60)
